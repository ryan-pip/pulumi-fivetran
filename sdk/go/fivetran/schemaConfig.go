// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fivetran

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
	"github.com/ryan-pip/pulumi-fivetran/sdk/go/fivetran/internal"
)

// ## ---
//
// page_title: "Resource: SchemaConfig"
// ---
//
// # Resource: SchemaConfig
//
// This resource allows you to manage the Standard Configuration settings of a connector:
//   - Define the schema change handling settings
//   - Enable and disable schemas, tables, and columns
//
// The resource is in **ALPHA** state. The resource schema and behavior are subject to change without prior notice.
//
// Known issues:
//   - Definition of `syncMode` for table causes infinite drifting changes in plan
//
// ## Usage guide
//
// Note that all configuration settings are aligned to the `schemaChangeHandling` settings,  except the settings explicitly specified in `schema`.
// In `schema`, you only override the default settings defined by the chosen `schemaChangeHandling` option. The default value for the `enabled` attribute is `true` so it can be omitted when you want to enable schemas, tables, or columns.
// The allowed `schemaChangeHandling` options are as follows:
// - `ALLOW_ALL`- all schemas, tables and columns are ENABLED by default. You only need  to explicitly specify DISABLED items or hashed tables
// - `BLOCK_ALL` - all schemas, tables and columns are DISABLED by default, the configuration only specifies ENABLED items
// - `ALLOW_COLUMNS` - all schemas and tables are DISABLED by default, but all columns are ENABLED by default, the configuration specifies ENABLED schemas and tables, and DISABLED columns
//
// Note that system-enabled tables and columns (such as primary and foreign key columns, and [system tables and columns](https://fivetran.com/docs/getting-started/system-columns-and-tables)) are synced regardless of the `schemaChangeHandling` settings and configuration. You can only disable non-locked columns in the system-enabled tables. If the configuration specifies any system tables or locked system table columns as disabled ( `enabled = "false"`), the provider just ignores these statements.
//
// ## Usage examples
//
// ## Import
//
// 1. To import an existing `fivetran_connector_schema_config` resource into your Terraform state, you need to get **Fivetran Connector ID** on the **Setup** tab of the connector page in your Fivetran dashboard. 2. Retrieve all connectors in a particular group using the [fivetran_group_connectors data source](/docs/data-sources/group_connectors). To retrieve existing groups, use the [fivetran_groups data source](/docs/data-sources/groups). 3. Define an empty resource in your `.tf` configurationhcl resource "fivetran_connector_schema_config" "my_imported_connector_schema_config" { }
//
// ```sh
//
//	$ pulumi import fivetran:index/schemaConfig:SchemaConfig
//
// Run the `terraform import` command
// ```
//
// ```sh
//
//	$ pulumi import fivetran:index/schemaConfig:SchemaConfig my_imported_connector_schema_config {your Fivetran Connector ID}
//
// ```
//
// 5.
//
// Use the `terraform state show` command to get the values from the stateterraform state show 'fivetran_connector_schema_config.my_imported_connector_schema_config' 6. Copy the values and paste them to your `.tf` configuration.
type SchemaConfig struct {
	pulumi.CustomResourceState

	// The unique identifier for the connector within the Fivetran system.
	ConnectorId          pulumi.StringOutput           `pulumi:"connectorId"`
	SchemaChangeHandling pulumi.StringOutput           `pulumi:"schemaChangeHandling"`
	Schemas              SchemaConfigSchemaArrayOutput `pulumi:"schemas"`
}

// NewSchemaConfig registers a new resource with the given unique name, arguments, and options.
func NewSchemaConfig(ctx *pulumi.Context,
	name string, args *SchemaConfigArgs, opts ...pulumi.ResourceOption) (*SchemaConfig, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ConnectorId == nil {
		return nil, errors.New("invalid value for required argument 'ConnectorId'")
	}
	if args.SchemaChangeHandling == nil {
		return nil, errors.New("invalid value for required argument 'SchemaChangeHandling'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SchemaConfig
	err := ctx.RegisterResource("fivetran:index/schemaConfig:SchemaConfig", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSchemaConfig gets an existing SchemaConfig resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSchemaConfig(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SchemaConfigState, opts ...pulumi.ResourceOption) (*SchemaConfig, error) {
	var resource SchemaConfig
	err := ctx.ReadResource("fivetran:index/schemaConfig:SchemaConfig", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SchemaConfig resources.
type schemaConfigState struct {
	// The unique identifier for the connector within the Fivetran system.
	ConnectorId          *string              `pulumi:"connectorId"`
	SchemaChangeHandling *string              `pulumi:"schemaChangeHandling"`
	Schemas              []SchemaConfigSchema `pulumi:"schemas"`
}

type SchemaConfigState struct {
	// The unique identifier for the connector within the Fivetran system.
	ConnectorId          pulumi.StringPtrInput
	SchemaChangeHandling pulumi.StringPtrInput
	Schemas              SchemaConfigSchemaArrayInput
}

func (SchemaConfigState) ElementType() reflect.Type {
	return reflect.TypeOf((*schemaConfigState)(nil)).Elem()
}

type schemaConfigArgs struct {
	// The unique identifier for the connector within the Fivetran system.
	ConnectorId          string               `pulumi:"connectorId"`
	SchemaChangeHandling string               `pulumi:"schemaChangeHandling"`
	Schemas              []SchemaConfigSchema `pulumi:"schemas"`
}

// The set of arguments for constructing a SchemaConfig resource.
type SchemaConfigArgs struct {
	// The unique identifier for the connector within the Fivetran system.
	ConnectorId          pulumi.StringInput
	SchemaChangeHandling pulumi.StringInput
	Schemas              SchemaConfigSchemaArrayInput
}

func (SchemaConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*schemaConfigArgs)(nil)).Elem()
}

type SchemaConfigInput interface {
	pulumi.Input

	ToSchemaConfigOutput() SchemaConfigOutput
	ToSchemaConfigOutputWithContext(ctx context.Context) SchemaConfigOutput
}

func (*SchemaConfig) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaConfig)(nil)).Elem()
}

func (i *SchemaConfig) ToSchemaConfigOutput() SchemaConfigOutput {
	return i.ToSchemaConfigOutputWithContext(context.Background())
}

func (i *SchemaConfig) ToSchemaConfigOutputWithContext(ctx context.Context) SchemaConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigOutput)
}

func (i *SchemaConfig) ToOutput(ctx context.Context) pulumix.Output[*SchemaConfig] {
	return pulumix.Output[*SchemaConfig]{
		OutputState: i.ToSchemaConfigOutputWithContext(ctx).OutputState,
	}
}

// SchemaConfigArrayInput is an input type that accepts SchemaConfigArray and SchemaConfigArrayOutput values.
// You can construct a concrete instance of `SchemaConfigArrayInput` via:
//
//	SchemaConfigArray{ SchemaConfigArgs{...} }
type SchemaConfigArrayInput interface {
	pulumi.Input

	ToSchemaConfigArrayOutput() SchemaConfigArrayOutput
	ToSchemaConfigArrayOutputWithContext(context.Context) SchemaConfigArrayOutput
}

type SchemaConfigArray []SchemaConfigInput

func (SchemaConfigArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SchemaConfig)(nil)).Elem()
}

func (i SchemaConfigArray) ToSchemaConfigArrayOutput() SchemaConfigArrayOutput {
	return i.ToSchemaConfigArrayOutputWithContext(context.Background())
}

func (i SchemaConfigArray) ToSchemaConfigArrayOutputWithContext(ctx context.Context) SchemaConfigArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigArrayOutput)
}

func (i SchemaConfigArray) ToOutput(ctx context.Context) pulumix.Output[[]*SchemaConfig] {
	return pulumix.Output[[]*SchemaConfig]{
		OutputState: i.ToSchemaConfigArrayOutputWithContext(ctx).OutputState,
	}
}

// SchemaConfigMapInput is an input type that accepts SchemaConfigMap and SchemaConfigMapOutput values.
// You can construct a concrete instance of `SchemaConfigMapInput` via:
//
//	SchemaConfigMap{ "key": SchemaConfigArgs{...} }
type SchemaConfigMapInput interface {
	pulumi.Input

	ToSchemaConfigMapOutput() SchemaConfigMapOutput
	ToSchemaConfigMapOutputWithContext(context.Context) SchemaConfigMapOutput
}

type SchemaConfigMap map[string]SchemaConfigInput

func (SchemaConfigMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SchemaConfig)(nil)).Elem()
}

func (i SchemaConfigMap) ToSchemaConfigMapOutput() SchemaConfigMapOutput {
	return i.ToSchemaConfigMapOutputWithContext(context.Background())
}

func (i SchemaConfigMap) ToSchemaConfigMapOutputWithContext(ctx context.Context) SchemaConfigMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SchemaConfigMapOutput)
}

func (i SchemaConfigMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*SchemaConfig] {
	return pulumix.Output[map[string]*SchemaConfig]{
		OutputState: i.ToSchemaConfigMapOutputWithContext(ctx).OutputState,
	}
}

type SchemaConfigOutput struct{ *pulumi.OutputState }

func (SchemaConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SchemaConfig)(nil)).Elem()
}

func (o SchemaConfigOutput) ToSchemaConfigOutput() SchemaConfigOutput {
	return o
}

func (o SchemaConfigOutput) ToSchemaConfigOutputWithContext(ctx context.Context) SchemaConfigOutput {
	return o
}

func (o SchemaConfigOutput) ToOutput(ctx context.Context) pulumix.Output[*SchemaConfig] {
	return pulumix.Output[*SchemaConfig]{
		OutputState: o.OutputState,
	}
}

// The unique identifier for the connector within the Fivetran system.
func (o SchemaConfigOutput) ConnectorId() pulumi.StringOutput {
	return o.ApplyT(func(v *SchemaConfig) pulumi.StringOutput { return v.ConnectorId }).(pulumi.StringOutput)
}

func (o SchemaConfigOutput) SchemaChangeHandling() pulumi.StringOutput {
	return o.ApplyT(func(v *SchemaConfig) pulumi.StringOutput { return v.SchemaChangeHandling }).(pulumi.StringOutput)
}

func (o SchemaConfigOutput) Schemas() SchemaConfigSchemaArrayOutput {
	return o.ApplyT(func(v *SchemaConfig) SchemaConfigSchemaArrayOutput { return v.Schemas }).(SchemaConfigSchemaArrayOutput)
}

type SchemaConfigArrayOutput struct{ *pulumi.OutputState }

func (SchemaConfigArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SchemaConfig)(nil)).Elem()
}

func (o SchemaConfigArrayOutput) ToSchemaConfigArrayOutput() SchemaConfigArrayOutput {
	return o
}

func (o SchemaConfigArrayOutput) ToSchemaConfigArrayOutputWithContext(ctx context.Context) SchemaConfigArrayOutput {
	return o
}

func (o SchemaConfigArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*SchemaConfig] {
	return pulumix.Output[[]*SchemaConfig]{
		OutputState: o.OutputState,
	}
}

func (o SchemaConfigArrayOutput) Index(i pulumi.IntInput) SchemaConfigOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SchemaConfig {
		return vs[0].([]*SchemaConfig)[vs[1].(int)]
	}).(SchemaConfigOutput)
}

type SchemaConfigMapOutput struct{ *pulumi.OutputState }

func (SchemaConfigMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SchemaConfig)(nil)).Elem()
}

func (o SchemaConfigMapOutput) ToSchemaConfigMapOutput() SchemaConfigMapOutput {
	return o
}

func (o SchemaConfigMapOutput) ToSchemaConfigMapOutputWithContext(ctx context.Context) SchemaConfigMapOutput {
	return o
}

func (o SchemaConfigMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*SchemaConfig] {
	return pulumix.Output[map[string]*SchemaConfig]{
		OutputState: o.OutputState,
	}
}

func (o SchemaConfigMapOutput) MapIndex(k pulumi.StringInput) SchemaConfigOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SchemaConfig {
		return vs[0].(map[string]*SchemaConfig)[vs[1].(string)]
	}).(SchemaConfigOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaConfigInput)(nil)).Elem(), &SchemaConfig{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaConfigArrayInput)(nil)).Elem(), SchemaConfigArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SchemaConfigMapInput)(nil)).Elem(), SchemaConfigMap{})
	pulumi.RegisterOutputType(SchemaConfigOutput{})
	pulumi.RegisterOutputType(SchemaConfigArrayOutput{})
	pulumi.RegisterOutputType(SchemaConfigMapOutput{})
}
